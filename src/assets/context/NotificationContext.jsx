import { createContext, useContext, useState, useEffect } from "react";
import toast from "react-hot-toast";
import * as notificationService from "../services/notificationService";
import { useAuth } from "./AuthContext";

const NotificationContext = createContext();

export const useNotifications = () => {
  const context = useContext(NotificationContext);
  if (!context) {
    throw new Error(
      "useNotifications must be used within a NotificationProvider"
    );
  }
  return context;
};

export const NotificationProvider = ({ children }) => {
  const [notifications, setNotifications] = useState([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const { user, isAuthenticated } = useAuth();

  // Fetch notifications from API
  const fetchNotifications = async () => {
    if (!isAuthenticated) return;
    try {
      const [personal, broadcasts, countData] = await Promise.all([
        notificationService.getNotifications(),
        notificationService.getBroadcasts(),
        notificationService.getUnreadCount(),
      ]);

      // Merge and sort by date descending
      const allNotifications = [...personal, ...broadcasts].sort(
        (a, b) => new Date(b.created_at) - new Date(a.created_at)
      );

      setNotifications(allNotifications);
      setUnreadCount(countData.unread_count);
    } catch (error) {
      console.error("Error fetching notifications:", error);
    }
  };

  // Initial fetch and polling
  useEffect(() => {
    if (isAuthenticated) {
      fetchNotifications();

      // Poll every 60 seconds
      const intervalId = setInterval(fetchNotifications, 60000);

      return () => clearInterval(intervalId);
    } else {
      setNotifications([]);
      setUnreadCount(0);
    }
  }, [isAuthenticated]);

  const addNotification = (notification) => {
    // For now, this might just trigger a refresh or optimistically add locally
    // But primarily, notifications come from the backend.
    // If this is used for "local" only feedback (like purchase success toast), we can keep it purely local or POST to backend if needed.
    // Assuming for this requirement, purchase notifications are generated by backend logic,
    // but if we need to force a refresh after an action:
    fetchNotifications();

    if (notification.showToast !== false) {
      toast(notification.message, { icon: "ðŸ””" });
    }
  };

  const markAsRead = async (id, isBroadcast = false) => {
    try {
      if (isBroadcast) {
        await notificationService.markBroadcastAsRead(id);
      } else {
        await notificationService.markNotificationAsRead(id);
      }
      // Optimistic update
      setNotifications((prev) =>
        prev.map((n) => (n.id === id ? { ...n, is_read: true } : n))
      );
      setUnreadCount((prev) => Math.max(0, prev - 1));

      // Verification fetch
      fetchNotifications();
    } catch (error) {
      console.error("Error marking as read:", error);
      toast.error("Error al marcar como leÃ­da");
    }
  };

  const markAllAsRead = async () => {
    // Implement iterating through unread if no bulk endpoint exists
    // Or ideally backend provides one.
    // For now, let's just refresh to stay simple or iterate clientside if needed
    // Given the prompt: "Iterate through unread items and call their respective read endpoints"
    const unread = notifications.filter((n) => !n.is_read);

    try {
      await Promise.all(
        unread.map((n) => {
          const isBroadcast = n.target_role !== undefined; // differentiate by field
          return isBroadcast
            ? notificationService.markBroadcastAsRead(n.id)
            : notificationService.markNotificationAsRead(n.id);
        })
      );
      fetchNotifications();
      toast.success("Todas marcadas como leÃ­das");
    } catch (error) {
      console.error("Error marking all read:", error);
    }
  };

  const deleteNotification = (id) => {
    // Backend doesn't seem to have DELETE endpoint in prompt,
    // maybe just hide locally or "mark as read" functions as archive?
    // User prompt didn't specify DELETE endpoint.
    // For now, we will just filter it out of state locally.
    setNotifications((prev) => prev.filter((n) => n.id !== id));
  };

  const clearAllNotifications = () => {
    setNotifications([]);
  };

  return (
    <NotificationContext.Provider
      value={{
        notifications,
        unreadCount,
        addNotification,
        markAsRead,
        markAllAsRead,
        deleteNotification,
        clearAllNotifications,
        refreshNotifications: fetchNotifications,
      }}
    >
      {children}
    </NotificationContext.Provider>
  );
};
